<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(六)SpringBoot过滤器、监听器和拦截器]]></title>
    <url>%2F2019%2F01%2F29%2F(%E5%85%AD)SpringBoot%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[概述&#160; &#160; &#160; &#160;该篇主要记录SpringBoot项目中如何使用 过滤器、监听器、拦截器。关于 过滤器、监听器和拦截器有过web开发经验的 同志们都知道，在web.xml中做相对应的配置，指定实现类即可。过滤器只能再web项目中使用，拦截器则都可以。过滤器和拦截器主要可以实现请求过滤，例如我们web项目判断一个请求之前要先拦截判断，是都有权限来访问，请求中是否带有合法的token等等功能。 过滤器首先创建一个SpringBoot项目。 创建一个MyFilter 实现接口Filter@WebFilter(filterName = &quot;myFilter&quot;,urlPatterns = {&quot;/*&quot;}) public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // TODO Auto-generated method stub System.out.println(&quot;MyFilter init &quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // TODO Auto-generated method stub HttpServletRequest req = (HttpServletRequest) request; System.out.println(&quot;MyFilter doFilter&quot;+req.getParameter(&quot;name&quot;)); chain.doFilter(request, response); return ; } @Override public void destroy() { // TODO Auto-generated method stub System.out.println(&quot;MyFilter destroy&quot;); } } 在该类上添加注解 @WebFilter(filterName = “myFilter”,urlPatterns = {“/*”}) 指定过滤器的名称和要过滤的地址。 在入口的启动类上添加注解@SpringBootApplication @ServletComponentScan public class FilterSpringBootApplication { public static void main(String[] args) { SpringApplication.run(FilterSpringBootApplication.class, args); } } 启动项目可以在启动的日志中看见 过滤器已经初始化了。 编写controller：FilterController @Controller public class FilterController { @RequestMapping(&quot;/testMyFilter&quot;) public String testMyFilter() { return &quot;Hello Filter&quot;; } } 重启项目，访问http://127.0.0.1:8080/testMyFilter?name=ccl 控制台输出正确。 指定过滤器顺序&#160; &#160; &#160; &#160;至此，一个过滤器就可以使用了，但是在我们平常的工作中一般有多个过滤器，并且要指定每个过滤器的顺序等等，那么用这种方式是没有办法 实现的，可以使用FilterRegistrationBean 来实现 1.将上面项目的 过滤器上的@WebFilter(filterName = “myFilter”,urlPatterns = {“/*”}) 去掉，将入口类的@ServletComponentScan去掉。 2.根据之前的做法再编写一个过滤器： MyFilterTwo public class MyFilterTwo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // TODO Auto-generated method stub System.out.println(&quot;MyFilterTwo init &quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // TODO Auto-generated method stub HttpServletRequest req = (HttpServletRequest) request; System.out.println(&quot;MyFilterTwo doFilter&quot;+req.getParameter(&quot;name&quot;)); chain.doFilter(request, response); return ; } @Override public void destroy() { // TODO Auto-generated method stub System.out.println(&quot;MyFilterTwo destroy&quot;); } } 编写java配置文件FilterConfig @Configuration public class FilterConfig { @Bean public FilterRegistrationBean filterRegistrationBean() { FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new MyFilter()); //指定过滤器的执行顺序 filterRegistrationBean.setOrder(2); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; } @Bean public FilterRegistrationBean filterRegistrationBean2() { FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new MyFilterTwo()); filterRegistrationBean.setOrder(1); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; } }然后启动项目 过滤器初始化成功 访问http://127.0.0.1:8080/testMyFilter?name=ccl 执行成功，且顺序和设置的一致。 监听器监听器主要是对对象自身的创建和销毁进行监听 主要有ServletContextListener、HttpSessionListener、ServletRequestListener，用法基本一致 下面以HttpSessionListener为例，用来监听 统计当前访问人数。 创建监听器1.首先创建一个CountListener实现HttpSessionListener public class CountListener implements HttpSessionListener { private int count = 0; @Override public void sessionCreated(HttpSessionEvent se) { // TODO Auto-generated method stub count++; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;新增在线人数，当前在线人数：&quot;+count); } @Override public void sessionDestroyed(HttpSessionEvent se) { // TODO Auto-generated method stub count--; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;删减在线人数，当前在线人数：&quot;+count); } } 配置文件2.创建配置文件类，注册该监听器 @Configuration public class ListenerConfig { @Bean public ServletListenerRegistrationBean&lt;CountListener&gt; countListenerServletRegistrationBean(){ return new ServletListenerRegistrationBean&lt;CountListener&gt;( new CountListener()); } } 创建controller3.创建controller @RestController public class ListenerConterller { @RequestMapping(&quot;/testListenerLogin&quot;) public String testListenerLogin(HttpServletRequest req) { System.out.println(&quot;当前在线人数&quot;+req.getSession().getId()+&quot;：&quot; +req.getSession().getServletContext().getAttribute(&quot;count&quot;)); return &quot;Hello testListenerLogin&quot;; } } 启动项目 访问http://127.0.0.1:8080/testListenerLogin 可以看见 再开启一个浏览器访问上述地址 得到我们想要的效果， 当然HttpSessionListener除了创建和销毁方法还有一些其他的方法可以实现。 上面使用java配置文件注册的方式注册监听器，当然还有更简单的，直接使用注解 使用WebListener1.在CountListener类上添加@WebListener注解，标记为监听器 @WebListener public class CountListener implements HttpSessionListener { private int count = 0; @Override public void sessionCreated(HttpSessionEvent se) { // TODO Auto-generated method stub count++; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;新增在线人数，当前在线人数：&quot;+count); } @Override public void sessionDestroyed(HttpSessionEvent se) { // TODO Auto-generated method stub count--; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;删减在线人数，当前在线人数：&quot;+count); } } 2.在项目的启动类上添加注解@ServletComponentScan扫描 @SpringBootApplication @ServletComponentScan public class ListenerSpringBootApplication { public static void main(String[] args) { SpringApplication.run(ListenerSpringBootApplication.class, args); } } 一样启动项目，用两个浏览器访问 http://127.0.0.1:8080/testListenerLogin 可以看见和之前是一样的效果 拦截器 拦截器和过滤器的功能类似，但是是不同的东西 过滤器只能在web项目中使用， 拦截器可以在非web项目中使用。 过滤器是servlet容器支持的，拦截器是spring支持的，所以拦截器可以使用spring的资源，例如数据源，可以注入的对象等等，而过滤器是不行的。 过滤器只在servlet前后起作用，但是拦截器可以深入 到方法前后等等，功能更强大，所以再spring中要优先使用拦截器 1.首先创建一个项目 创建拦截器创建一个类MyInterceptor 实现HandlerInterceptor @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // TODO Auto-generated method stub System.out.println(&quot;preHandle....&quot;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // TODO Auto-generated method stub System.out.println(&quot;postHandle....&quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // TODO Auto-generated method stub System.out.println(&quot;postHandle....&quot;); } } 拦截器配置 2.创建java配置类InterceptorConfig 继承WebMvcConfigurerAdapter @Configuration public class InterceptorConfig extends WebMvcConfigurerAdapter{ @Autowired MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册拦截器 拦截规则 //多个拦截器时 以此添加 执行顺序按添加顺序 registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/*&quot;); } } 创建controller3.创建controller . @Controller public class InterceptorCotroller { @RequestMapping(&quot;/testinterceptor&quot;) public ModelAndView testInterceptor() { System.out.println(&quot;进入controller&quot;); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;aaa&quot;); System.out.println(&quot;即将返回modelandview&quot;); return mv; } } 4.启动项目访问http://127.0.0.1:8080/testinterceptor。 至此，过滤器、拦截器、监听器的基本使用完成，在实际项目中主要是考虑编写拦截业务等。例如在拦截器上判断是否进行黑白名单拦截，或者判断redis中token是否过期来判断是否可以访问请求。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(五)SpringBoot热部署]]></title>
    <url>%2F2019%2F01%2F29%2F(%E4%BA%94)SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;在前面的开发中不知道各位有没有发现，我们前端页面做修改只要保存， 不需要重启项目，重新访问就可以看见效果，但是在后端，例如controller中我们要改一个很小的值都要重新项目才能生效，这就显得特别的麻烦，所以，热部署可以让我们实现 类似前端页面保存就可以生效的效果，只需要加一个热部署的依赖即可。以之前的jsp demo为 例，在pom文件中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 重启项目，修改 controller 修改之后保存，直接访问 http://127.0.0.1:8080/testjsp，就可以发现，后台传过来的值已经变化了 页面模板 热部署，我就从书上截图下来]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(四)SpringBoot页面模板与JSP]]></title>
    <url>%2F2019%2F01%2F28%2F(%E5%9B%9B)SpringBoot%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF%E4%B8%8EJSP%2F</url>
    <content type="text"><![CDATA[概述虽然在我们现在工作中，后端 人员一般只写接口，前后端分离，一般也使用不到页面模板，但是官方推荐使用thymeleaf，这边就蛮记录一下，对于jsp做过web开发的同志应该都会清楚，一些老项目基本是使用jsp，虽然官方已经不建议使用了，但是还是要了解一下。 Thymeleaf 了解thymeleaf之前我们要知道，SpringBoot默认的几个静态页面的目录： /static、/public、/resources 、/META-INF/resources 创建项目我们可以将项目中使用到的静态文件放在这几个项目中 首先我们创建一个SpringBoot项目 1.加入thymeleaf依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2.编写controller @Controller public class ThymeleafController { @RequestMapping(value = &quot;/testthymeleaf&quot;) public ModelAndView test(ModelAndView mv) { mv.setViewName(&quot;thymeleaf1&quot;); mv.addObject(&quot;name&quot;,&quot;欢迎使用Thymeleaf!&quot;); return mv; } } 3.在src/main/resources/templates目录下创建 thymeleaf.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;thymeleaf demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello thymeleaf&lt;/h1&gt; &lt;h2 th:text=&quot;&apos;名称：&apos;+${name}&quot;&gt;默认值&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 4.配置thymel信息，在application.properties下配置 #thymelea模板配置 spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.mode=HTML5 spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.content-type=text/html spring.thymeleaf.cache=false spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** 5.启动项目，浏览器访问http://127.0.0.1:8080/testthymeleaf 至此，Thymeleaf整合成功，当然thymeleaf还有很多内容，但是我个人也没用过，只是稍微了解 。 如果按照上面的做法 之后访问报404 的话 检查一下SpringBoot的版本，设置为1.3.3就可以解决了。 JSP对于一些老项目基本都是使用jsp，所以SpringBoot也有提供对jsp的支持 1.添加jsp的依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; 2.编写controller @Controller public class JspController { @GetMapping(&quot;/testjsp&quot;) public ModelAndView index() { ModelAndView mv = new ModelAndView(); mv.addObject(&quot;name&quot;, &quot;ccl&quot;); //模版名称，实际的目录为：src/main/webapp/jsp/index.html mv.setViewName(&quot;test&quot;); return mv; } } 3.在src/main/webapp/WEB-INF/jsp下创建test.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charsetUTF-8&quot;&gt; &lt;title&gt;jsp demo &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Jsp&lt;/h1&gt; &lt;h2 &gt;这是 ${name} 的jsp&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 4.配置jsp，在application.properties里配置： #jsp 支持 spring.mvc.view.suffix=.jsp spring.mvc.view.prefix=/WEB-INF/jsp/ 如果SpringBoot的版本太低的话配置为： #jsp 支持 spring.view.suffix=.jsp spring.view.prefix=/WEB-INF/jsp/ 5.启动项目，浏览器访问http://127.0.0.1:8080/testjsp 至此。SpringBoot整合jsp成功。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(三)SpringBoot配置和多环境]]></title>
    <url>%2F2019%2F01%2F28%2F(%E4%B8%89)SpringBoot%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%9A%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[配置文件介绍&#160; &#160; &#160; &#160;在第一个Springboot项目中我们知道，SpringBoot项目的默认 配置文件在main/resources下的application.properties下，我们接直接用之前的项目了解一下配置文件。&#160; &#160; &#160; &#160;application.properties配置文件中 配置整个springboot所需的配置，例如端口，项目名称，redis信息，到后续开发springcloud时的注册中心等等的配置信息，当然也可以自己自定义的配置项。 新增配置项&#160; &#160; &#160; &#160;我们打开application.properties，添加配置项： server.port=8083 name=this is default &#160; &#160; &#160; &#160;然后改写之前的HelloSpringBootController类 @RestController public class HelloSpringBootController { @Value(&quot;${name}&quot;) private String name; @RequestMapping(&quot;/sayHello&quot;) public String sayHello() { return &quot;Hello ,&quot;+this.name; } } 运行 接着启动项目可以看见： 启动了8083 端口 我们访问一下http://127.0.0.1:8083/sayHello，效果如下： 访问 成功，配置项正确获取了。 多环境配置但是在我们正常的开发中会有多个环境，测试环境，开发环境，生产环境，联调环境等等，每个环境下的配置不尽相同，那就需要我们配置多环境的配置文件： 首先在main/resources下 创建以下几个环境配置文件 修改各个配置文件的端口和name值 指定环境在application.properties下设置： spring.profiles.active=prod 确定当前使用的是哪个环境，这边环境的值与application-prod.properties中-后面的值对应，这是SpringBoot约定好的， 启动项目： 会发现启动了application-prod,properties配置下的8082端口，因为我们设置了当前的环境是prod，所以application-prod,properties生效了。 在浏览器中输入http://127.0.0.1:8082/sayHello，效果如下： 获取到 了正确的端口和值，可以依次测试各个环境。 基本的多环境配置如上述。 配置文件加载顺序 在命令行中传入的参数。 SPRING APPLICATION JSON 中 的属性. SPRING APPLICATION JSON 是 以JSON格式配置在系统环境变量中的内容。 3.javacomp/env中的JNDI属性。 4.Java的系统属性，可以通过system.getpropertieso获得的内容。 5.操作系统的环境变量。 6.通过random.*配置的随机属性。 7.位于当前应用怬包之外，针对不同(profile}环境的配置文件内容，例如application-{profile}·properties或是YAML定义的配置文件。 8.位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件。 9.位于当前应用jar包之外的application.properties和YAML配置内容。 10.位于当前应用jar包之内的application.properties和YAML配置内容。 11.在@Configuration注解修改的类中，通过@propertysource注解定义的属性。 12.应用默认属性，使用SpringApplication.setDefaultproperties定义的内容。优先级按上面的顺序由高到低，数字越小优先级越高。 项目打包发布但是在工作项目中我们将一个项目打包之后发布，springboot 项目使用java -jar xxx.jar 来启动项目。那么我们现在打包之后部署在开发环境中，配置文件中应该这样配置 spring.profiles.active=dev那么如果我们要将项目部署到测试环境中，是不是需要修改一下配置文件，然后重新打包部署呢？显然不是的，当然有更好的办法来解决。 首先我们将 项目打包，当然我们一般会有一些自动打包的脚本，但是这边我就 直接使用cmd打包 打开cmd进入当前项目的目录 运行mvn install （首先确认你已经安装了maven并且配置好环境变量，mvn是可以运行的） 运行成功之后进入target目录会看见，项目已经打包成jar了 cmd 继续进入target目录 （jar所在的目录） 运行： java -jar PropertiesSpringBoot-0.0.1-SNAPSHOT.jar --spring.profiles.active=test运行jar包，并使用–配置项=值，来设置配置项 可以看见启动了测试环境8083 访问正确！]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(二)创建一个简单的SpringBoot应用]]></title>
    <url>%2F2019%2F01%2F28%2F(%E4%BA%8C)%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;接下来，我们就 一起来创建第一个SpringBoot 应用。创建SpringBoot项目过程中就会发现为什么SpringBoot会这么受欢迎了。关于IDE,写文章的时候使用的是Spring Tool Suite（STS），现在已经转为Idea，看个人喜好吧，自己怎么舒服怎么来，在工作中也没有强制一定要使用什么IDE。 言归正传， 下面的教程都是使用STS。 创建项目创建一个Spring Starter project 点击NEXT 选择对用的版本和WEB项目然后选择finish首先创建一个项目 POM.XML打开项目的POM.XML 你会发现自动给你导入了一些依赖&#160; &#160; &#160; &#160;首先导入SpringBoot的依赖，因为我们刚才创建项目的时候选择了web， 所以还 自动导入了spring-boot-starter-web依赖。你也可以创建一个普通的 Maven然后将这些依赖导入一下是一个意思。 项目目录 项目入口类：类上使用@SpringBootApplication 标识 该类为项目的入口类 然后我们创建一个包 编写Controller &#160; &#160; &#160; &#160;注意我们创建的包必须是在程序入口类 所在包的子包，这样写的@RestController才会被扫描到 &#160; &#160; &#160; &#160;接着我们启动项目，在入口类上 右键==》Run as ==》 Spring Boot App 程序成功启动，默认端口为 8080 浏览器上输入：http://localhost:8080/sayHello 输出。完毕 一个简单的SpringBoot的项目就搭建成功了，非常方便，少去了spring spring mvc的配置，就可以快速的创建一个web项目。 一般来说使用SpringBoot的其他功能的步骤： 1.添加依赖 2..使用注解编写一些配置或代码 就可以了 。 题外话：&#160; &#160; &#160; &#160;启动的时候这块 标志是可以修改的，在java/main/resource 下创建一个banner.txt 文件，里面写入你要的内容，启动就可以看见这块标识已经 被修改了。 要生成类似的字体可以访问http://patorjk.com/software/taag去生成.其实没啥用。。。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(一)SpringBoot概述]]></title>
    <url>%2F2019%2F01%2F28%2F(%E4%B8%80)SpringBoot%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是SpringBoot&#160; &#160; &#160; &#160;我们知道Spring使用一个轻量级的企业开发一站式解决方案，提供了最主要的IOC、AOP等相关支持，但是在开发过程中会发现，项目中多而繁杂的配置文件总是让人头疼。而SpringBoot就是使用默认的配置来简化开发过程。 &#160; &#160; &#160; &#160;随着动态语言的发展，传统的Java开发显得格外的笨重，效率低，配置文件多且杂，部署流程复杂，集成第三方难度大，所以 出现了SpringBoot。&#160; &#160; &#160; &#160;之前看过一句话,什么是SpringBoot？SpringBoot是一个专注于框架的框架。说白了SpringBoot就是简化开发， 提高效率的这么一个东西。 SpringBoot应用可以打包成jar 以jar包 形式运行 SpringBoot内职tomcat、jetty等，我们可 以像运行java application那样运行一个java web项目 SpringBoot提供 starter来简化Maven配置，我们只需要导入几个starter就可以省去好多 maven的配置 SpringBoot无代码生成和XML配置，使用“习惯优于配置“” 的想法来开发项目，在使用它的时候一般使用一些 注解，就可以完成，不需要写代码 SpringBoot对第三方的支持，支持各种第三方，只要导入依赖就能快速的使用，例如Mybatis等 &#160; &#160; &#160; &#160;说了这么多，还不如动手来试试 接下来我们来创建一个SpringBoot应用。 网上有很多大佬写了SpringBoot系列博客，该博文主要作为自己的技术总结，也希望对正在学习的朋友们有些许帮助。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
