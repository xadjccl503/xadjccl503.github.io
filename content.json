{"meta":{"title":"xadjccl","subtitle":null,"description":null,"author":"xadjccl","url":"http://yoursite.com"},"pages":[{"title":"关于作者","date":"2019-01-27T06:12:29.000Z","updated":"2019-01-29T07:24:06.290Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"&#160; &#160; &#160; &#160;都说人生是一场修行，我们曾经觉得用编码可以改变世界，到头来还是被生活磨平了棱角。即使这样，不用忘记你曾经第一次运行Hello World心中的渴望和梦想。你敲下的每一行代码，终究会是你一生的财富。"},{"title":"tags","date":"2019-01-27T06:12:22.000Z","updated":"2019-01-27T07:43:00.742Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-27T06:11:55.000Z","updated":"2019-01-27T07:43:11.025Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring源码学习笔记_容器的基本实现","slug":"Spring源码学习笔记_容器的基本实现","date":"2019-02-14T01:58:47.874Z","updated":"2019-02-14T08:27:41.158Z","comments":false,"path":"2019/02/14/Spring源码学习笔记_容器的基本实现/","link":"","permalink":"http://yoursite.com/2019/02/14/Spring源码学习笔记_容器的基本实现/","excerpt":"","text":"获取Spring源码下载工程&#160; &#160; &#160; &#160; 下载工程：首先先确认已正确安装Git，使用Git 下载地址：git://github.com/SpringSource/Spring-framework.git 导入Idea&#160; &#160; &#160; &#160; 导入Idea：下载源码之后cmd到该目录，输入命令gradlew 构建gradle项目，导入Idea 容器的基本使用和源码解析使用：创建测试Beanpublic class MyTestBean { private String testStr = &quot;testStr&quot;; public String getTestStr() { return testStr; } public void setTestStr(String testStr) { this.testStr = testStr; } } 配置文件BeanFactoryTest.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;myTestBean&quot; class=&quot;com.ccl.ioc.MyTestBean&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 测试类：public class BeanFactoryTest { @Test public void testSimpleLoad(){ BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;beanFactoryTest.xml&quot;)); MyTestBean bean = (MyTestBean) bf.getBean(&quot;myTestBean&quot;); Assert.assertEquals(&quot;testStr&quot;,bean.getTestStr()); } } &#160; &#160; &#160; &#160;上述代码中主要完成的功能为：读取配置文件、根据配置文件找到对应的类配置，调用实例。 核心类DefaultListableBeanFactory&#160; &#160; &#160; &#160;XmlBeanFactory继承DefaultListableBeanFactory，DefaultListableBeanFactory是整个bean加载的核心部分。结构图： XMLBeanDefinitionReader读取配置文件流程： 1.XmlBeanDefinitionReader继承AbstractBeanDefinitionReader 使用ResourLoader将文件路径转化为Resource文件 2.通过DocumentLoader对Resource文件进行转化为Document文件 通过BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader对Document进行解析，并使用BeanDefinitionParseDelegate对Element进行解析。 XmlFactoryBeanXmlBeanFactory 扩展了DefaultListableBeanFactory 并定义了读取Xml文件中Beandifinition的XMLBeanDefinitionReader。时序图： 源代码分析BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;beanFactoryTest.xml&quot;)); 进入 XmlBeanFactory.java public XmlBeanFactory(Resource resource) throws BeansException { // 调用XmlBeanFactory（Resource，BeanFactory） this(resource, null); } 构造方法中的参数是Resource 而上面代码中是ClassPathResource 。首先了解一下构造方法中的参数ResourceResource继承于InputStreamSource快捷键alt+7查看所有的方法Resource接口抽象了所有Spring内部使用到的底层资源File、URL、ClassPath等。上图中可以看见它定义了判断资源状态如：是否存在、是否可读、是否打开等。对于不同来源的资源文件有对应的Resource实现。文件资源FileSystemResource、ClassPath资源ClassPathResource、URL资源URLResource、Input资源InputResource等。InputStreamSource 只有一个方法getInputStream()返回一个新的Inputstream对象。 首先通过ClassPathResource封装来读取配置文件接着源码继续调用内部构造方法 public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { super(parentBeanFactory); // XmlBeanDefinitionReader加载资源真正的实现 this.reader.loadBeanDefinitions(resource); } 主要看XmlBeanDefinitionReader类型的reader提供的loadBeanDefinitions方法。跟进源码首先画出时序图了解大致的调用情况进入方法： public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { return loadBeanDefinitions(new EncodedResource(resource)); } 使用EncodedResource对resource进行封装，EncodedResource主要是对文件的编码进行处理，当设置了编码的时候Spring会使用相对应的编码作为输入流的编码。接着进入内部方法loadBeanDefinitions： public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isTraceEnabled()) { logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource); } //通过属性来记录已经加载的资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); } try { // 从encodedResource中获取Resource再获取inputStream InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } // 真正的核心逻辑部分 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { // 关闭输入流 inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } } } 通过SAX获取XML文件的Input对象，接着调用内部方法doLoadBeanDefinitions： protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 1 Document doc = doLoadDocument(inputSource, resource); // 2 int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource); } return count; } catch (BeanDefinitionStoreException ex) { throw ex; } catch (SAXParseException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (SAXException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (ParserConfigurationException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); } catch (IOException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); } catch (Throwable ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); } } 上述代码主要功能：获取XML文件的验证模式 、加载XML文件，得到对应的Document、根据返回的Document注册Bean信息。 获取XML的验证模式XML文件的验证模式主要是为了保证XML文件的正确性，主要的验证模式有DTD和XSD DTDDTD（Document Type Definition）即文档类型定义是一种XML约束模式语言。主要是通过比较XML文件和DTD文件来判断文档是否符合规范。DTD验证模式需要在XML文件的头部声明： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN 2.0//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;&gt; XSDXSD（XML Schemas Defidition）XML Schemas 描述了XML结构。可以用指定的XML Schemas来验证某个XML是否符合要求。XML Schemas本身也是一个XML。使用XML Schemas对XML文档进行检验时，要声明名称空间xmlns=”http://www.springframework.org/schema/beans&quot;还要指定该名称空间对应的的XML Schemas文档的存储路径：xsi:schemaLocation=”http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ... &lt;/beans&gt; 可以在项目中查看DTD文件和XSD文件： 接着看上面代码Document doc = doLoadDocument(inputSource, resource);内容： protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception { return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware()); } 其中getValidationModeForResource(resource)用来获取XML文件的验证模式 protected int getValidationModeForResource(Resource resource) { int validationModeToUse = getValidationMode(); // 如果手动设置了验证模式就使用手动设置的验证模式 if (validationModeToUse != VALIDATION_AUTO) { return validationModeToUse; } // 没有手动设置的话直接自动识别文档的验证模式 int detectedMode = detectValidationMode(resource); if (detectedMode != VALIDATION_AUTO) { return detectedMode; } // Hmm, we didn&apos;t get a clear indication... Let&apos;s assume XSD, // since apparently no DTD declaration has been found up until // detection stopped (before finding the document&apos;s root tag). return VALIDATION_XSD; } 跟代码int detectedMode = detectValidationMode(resource);进入XmlValidationModeDetector.java中查看真正的识别验证模式的逻辑： public int detectValidationMode(InputStream inputStream) throws IOException { // Peek into the file to look for DOCTYPE. BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); try { boolean isDtdValidated = false; String content; while ((content = reader.readLine()) != null) { content = consumeCommentTokens(content); // 如果读取的行是空获取是注释则略过 if (this.inComment || !StringUtils.hasText(content)) { continue; } // 判断文档中是都存在DOCTYPE if (hasDoctype(content)) { isDtdValidated = true; break; } if (hasOpeningTag(content)) { // End of meaningful data... break; } } return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD); } catch (CharConversionException ex) { // Choked on some character encoding... // Leave the decision up to the caller. return VALIDATION_AUTO; } finally { reader.close(); } } 上述代码主要就是读取文档判断文档中是否存在DOCTYPE这个字符串。如果存在则认为是DTD模式，如果不存在则是XSD模式。验证文档模式之后，就真正的加载文档，跟到DefaultDocumentLoader.java中 public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception { DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isTraceEnabled()) { logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;); } DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource); } 这部分代码使用SAX解析XML文档。解析文档之后进入到int count = registerBeanDefinitions(doc, resource);来解析和注册BeanDefinitions public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 使用DefaultBeanDefinitionDocumentReader 实例化BeanDefinitionDocumentReader BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 记录统计前BeanDefinition的加载个数 int countBefore = getRegistry().getBeanDefinitionCount(); // 加载及注册bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // 记录本次加载的BeanDefinition个数 return getRegistry().getBeanDefinitionCount() - countBefore; } 跟代码进入documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; // 核心逻辑 doRegisterBeanDefinitions(doc.getDocumentElement()); } 进入DefaultBeanDefinitionDocumentReader.java protected void doRegisterBeanDefinitions(Element root) { BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { // 处理profile属性 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); // 解析并注BeanDefidition parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; } 跟代码进入parseBeanDefinitions(root, this.delegate); protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { parseDefaultElement(ele, delegate); } else { delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); } } 在Spring配置文件中Bean的声明有两类： 1.默认配置 2.自定义：tx:annotation-driven/ 代码delegate.isDefaultNamespace(root)来判断是否是默认配置 public boolean isDefaultNamespace(@Nullable String namespaceUri) { //BEANS_NAMESPACE_URI = &quot;http://www.springframework.org/schema/beans&quot;; return (!StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri)); } public boolean isDefaultNamespace(Node node) { return isDefaultNamespace(getNamespaceURI(node)); } 如果是Spring默认配置： parseDefaultElement(ele, delegate);如果是自定义配置：delegate.parseCustomElement(ele); Spring源码文章主要是本人在学习郝佳的《Spring源码深度解学习》时的学习笔记，巩固学习也希望可以帮助正在学习的朋友。有兴趣的朋友可以直接阅读书本，但是书本的内容总是感觉很多，学习笔记主要也是挑点重点记录。","categories":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://yoursite.com/categories/Spring源码/"}],"tags":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://yoursite.com/tags/Spring源码/"}]},{"title":"(七)SpringBoot统一异常处理","slug":"(七)SpringBoot统一异常处理","date":"2019-01-29T07:07:29.827Z","updated":"2019-01-29T07:07:29.827Z","comments":false,"path":"2019/01/29/(七)SpringBoot统一异常处理/","link":"","permalink":"http://yoursite.com/2019/01/29/(七)SpringBoot统一异常处理/","excerpt":"概述&#160; &#160; &#160; &#160;在我们项目中，运行时异常是非常容易出现的，前端页面进行请求如果发生异常会把异常的信息直接显示在前端页面上，这可能会导致一些敏感信息泄露，而且默认的异常信息一般也不好看，对我们排查问题也不是很方便，所以在项目中使用 统一的异常处理是非常有必要的。话不多说，直接上代码。","text":"概述&#160; &#160; &#160; &#160;在我们项目中，运行时异常是非常容易出现的，前端页面进行请求如果发生异常会把异常的信息直接显示在前端页面上，这可能会导致一些敏感信息泄露，而且默认的异常信息一般也不好看，对我们排查问题也不是很方便，所以在项目中使用 统一的异常处理是非常有必要的。话不多说，直接上代码。 创建项目1.创建一个springboot的项目 POM.XMLpom文件中添加依赖 &lt;!--lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 创建controller2.编写一个controller package com.ccl.demo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class ExceptionController { @RequestMapping(&quot;/testexception&quot;) public String testexception() { // 模拟出现异常情况 int i = 1/0; return &quot;testexception&quot;; } } 启动项目 访问 ：http://127.0.0.1:8080/testexception 会出现： 这个是默认情况下的一个异常出现的情况。接下来我们进行异常统一处理 创建异常类3.编写一个异常类 package com.ccl.demo.exception; import lombok.Builder; import lombok.Data; @Data @Builder public class CommonException { /** * 异常代码 */ private String exceptionCode; /** * 异常信息 */ private String exceptionMsg; public CommonException() { } public CommonException(String exceptionCode, String exceptionMsg) { this.exceptionCode = exceptionCode; this.exceptionMsg = exceptionMsg; } @Override public String toString() { return &quot;CommonException [exceptionCode=&quot; + exceptionCode + &quot;, &quot; + &quot;exceptionMsg=&quot; + exceptionMsg + &quot;]&quot;; } } 创建异常处理类4.异常处理类 package com.ccl.demo.exception; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.ResponseStatus; import lombok.extern.slf4j.Slf4j; @ControllerAdvice @Slf4j @ResponseBody @ResponseStatus(value = HttpStatus.OK) public class CommonExceptionHandler { //处理ArithmeticException 异常 @ExceptionHandler(ArithmeticException.class) public String handleArithmeticException(ArithmeticException ex) { log.info(&quot;异常信息&quot;, ex); CommonException commonException = new CommonException(); commonException.setExceptionCode(&quot;001&quot;); commonException.setExceptionMsg(&quot;除数不能为0&quot;+ex.getMessage()); return commonException.toString(); } } 上面我们对除以0发生的ArithmeticException异常进行统一处理 重启项目，访问http://127.0.0.1:8080/testexception 页面效果： 前端页面就会显示我们自定义的异常信息，这样便于我们排错和控制异常信息的输出。 基本上统一异常处理就完成了，这边写的有些简便，一般情况下在异常处理类中的 commonException.setExceptionCode(&quot;001&quot;); commonException.setExceptionMsg(&quot;除数不能为0&quot;+ex.getMessage()); 这两句要使用枚举类进行管理，各个模块约定好各自的异常编码和异常信息这样对我们排查问题会方便许多","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"(六)SpringBoot过滤器、监听器和拦截器","slug":"(六)SpringBoot过滤器、监听器和拦截器","date":"2019-01-29T06:55:15.566Z","updated":"2019-01-29T07:02:11.080Z","comments":false,"path":"2019/01/29/(六)SpringBoot过滤器、监听器和拦截器/","link":"","permalink":"http://yoursite.com/2019/01/29/(六)SpringBoot过滤器、监听器和拦截器/","excerpt":"概述&#160; &#160; &#160; &#160;该篇主要记录SpringBoot项目中如何使用 过滤器、监听器、拦截器。关于 过滤器、监听器和拦截器有过web开发经验的 同志们都知道，在web.xml中做相对应的配置，指定实现类即可。过滤器只能再web项目中使用，拦截器则都可以。过滤器和拦截器主要可以实现请求过滤，例如我们web项目判断一个请求之前要先拦截判断，是都有权限来访问，请求中是否带有合法的token等等功能。","text":"概述&#160; &#160; &#160; &#160;该篇主要记录SpringBoot项目中如何使用 过滤器、监听器、拦截器。关于 过滤器、监听器和拦截器有过web开发经验的 同志们都知道，在web.xml中做相对应的配置，指定实现类即可。过滤器只能再web项目中使用，拦截器则都可以。过滤器和拦截器主要可以实现请求过滤，例如我们web项目判断一个请求之前要先拦截判断，是都有权限来访问，请求中是否带有合法的token等等功能。 过滤器首先创建一个SpringBoot项目。 创建一个MyFilter 实现接口Filter@WebFilter(filterName = &quot;myFilter&quot;,urlPatterns = {&quot;/*&quot;}) public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // TODO Auto-generated method stub System.out.println(&quot;MyFilter init &quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // TODO Auto-generated method stub HttpServletRequest req = (HttpServletRequest) request; System.out.println(&quot;MyFilter doFilter&quot;+req.getParameter(&quot;name&quot;)); chain.doFilter(request, response); return ; } @Override public void destroy() { // TODO Auto-generated method stub System.out.println(&quot;MyFilter destroy&quot;); } } 在该类上添加注解 @WebFilter(filterName = “myFilter”,urlPatterns = {“/*”}) 指定过滤器的名称和要过滤的地址。 在入口的启动类上添加注解@SpringBootApplication @ServletComponentScan public class FilterSpringBootApplication { public static void main(String[] args) { SpringApplication.run(FilterSpringBootApplication.class, args); } } 启动项目可以在启动的日志中看见 过滤器已经初始化了。 编写controller：FilterController @Controller public class FilterController { @RequestMapping(&quot;/testMyFilter&quot;) public String testMyFilter() { return &quot;Hello Filter&quot;; } } 重启项目，访问http://127.0.0.1:8080/testMyFilter?name=ccl 控制台输出正确。 指定过滤器顺序&#160; &#160; &#160; &#160;至此，一个过滤器就可以使用了，但是在我们平常的工作中一般有多个过滤器，并且要指定每个过滤器的顺序等等，那么用这种方式是没有办法 实现的，可以使用FilterRegistrationBean 来实现 1.将上面项目的 过滤器上的@WebFilter(filterName = “myFilter”,urlPatterns = {“/*”}) 去掉，将入口类的@ServletComponentScan去掉。 2.根据之前的做法再编写一个过滤器： MyFilterTwo public class MyFilterTwo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // TODO Auto-generated method stub System.out.println(&quot;MyFilterTwo init &quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // TODO Auto-generated method stub HttpServletRequest req = (HttpServletRequest) request; System.out.println(&quot;MyFilterTwo doFilter&quot;+req.getParameter(&quot;name&quot;)); chain.doFilter(request, response); return ; } @Override public void destroy() { // TODO Auto-generated method stub System.out.println(&quot;MyFilterTwo destroy&quot;); } } 编写java配置文件FilterConfig @Configuration public class FilterConfig { @Bean public FilterRegistrationBean filterRegistrationBean() { FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new MyFilter()); //指定过滤器的执行顺序 filterRegistrationBean.setOrder(2); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; } @Bean public FilterRegistrationBean filterRegistrationBean2() { FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new MyFilterTwo()); filterRegistrationBean.setOrder(1); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; } }然后启动项目 过滤器初始化成功 访问http://127.0.0.1:8080/testMyFilter?name=ccl 执行成功，且顺序和设置的一致。 监听器监听器主要是对对象自身的创建和销毁进行监听 主要有ServletContextListener、HttpSessionListener、ServletRequestListener，用法基本一致 下面以HttpSessionListener为例，用来监听 统计当前访问人数。 创建监听器1.首先创建一个CountListener实现HttpSessionListener public class CountListener implements HttpSessionListener { private int count = 0; @Override public void sessionCreated(HttpSessionEvent se) { // TODO Auto-generated method stub count++; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;新增在线人数，当前在线人数：&quot;+count); } @Override public void sessionDestroyed(HttpSessionEvent se) { // TODO Auto-generated method stub count--; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;删减在线人数，当前在线人数：&quot;+count); } } 配置文件2.创建配置文件类，注册该监听器 @Configuration public class ListenerConfig { @Bean public ServletListenerRegistrationBean&lt;CountListener&gt; countListenerServletRegistrationBean(){ return new ServletListenerRegistrationBean&lt;CountListener&gt;( new CountListener()); } } 创建controller3.创建controller @RestController public class ListenerConterller { @RequestMapping(&quot;/testListenerLogin&quot;) public String testListenerLogin(HttpServletRequest req) { System.out.println(&quot;当前在线人数&quot;+req.getSession().getId()+&quot;：&quot; +req.getSession().getServletContext().getAttribute(&quot;count&quot;)); return &quot;Hello testListenerLogin&quot;; } } 启动项目 访问http://127.0.0.1:8080/testListenerLogin 可以看见 再开启一个浏览器访问上述地址 得到我们想要的效果， 当然HttpSessionListener除了创建和销毁方法还有一些其他的方法可以实现。 上面使用java配置文件注册的方式注册监听器，当然还有更简单的，直接使用注解 使用WebListener1.在CountListener类上添加@WebListener注解，标记为监听器 @WebListener public class CountListener implements HttpSessionListener { private int count = 0; @Override public void sessionCreated(HttpSessionEvent se) { // TODO Auto-generated method stub count++; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;新增在线人数，当前在线人数：&quot;+count); } @Override public void sessionDestroyed(HttpSessionEvent se) { // TODO Auto-generated method stub count--; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); System.out.println(&quot;删减在线人数，当前在线人数：&quot;+count); } } 2.在项目的启动类上添加注解@ServletComponentScan扫描 @SpringBootApplication @ServletComponentScan public class ListenerSpringBootApplication { public static void main(String[] args) { SpringApplication.run(ListenerSpringBootApplication.class, args); } } 一样启动项目，用两个浏览器访问 http://127.0.0.1:8080/testListenerLogin 可以看见和之前是一样的效果 拦截器 拦截器和过滤器的功能类似，但是是不同的东西 过滤器只能在web项目中使用， 拦截器可以在非web项目中使用。 过滤器是servlet容器支持的，拦截器是spring支持的，所以拦截器可以使用spring的资源，例如数据源，可以注入的对象等等，而过滤器是不行的。 过滤器只在servlet前后起作用，但是拦截器可以深入 到方法前后等等，功能更强大，所以再spring中要优先使用拦截器 1.首先创建一个项目 创建拦截器创建一个类MyInterceptor 实现HandlerInterceptor @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // TODO Auto-generated method stub System.out.println(&quot;preHandle....&quot;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // TODO Auto-generated method stub System.out.println(&quot;postHandle....&quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // TODO Auto-generated method stub System.out.println(&quot;postHandle....&quot;); } } 拦截器配置 2.创建java配置类InterceptorConfig 继承WebMvcConfigurerAdapter @Configuration public class InterceptorConfig extends WebMvcConfigurerAdapter{ @Autowired MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册拦截器 拦截规则 //多个拦截器时 以此添加 执行顺序按添加顺序 registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/*&quot;); } } 创建controller3.创建controller . @Controller public class InterceptorCotroller { @RequestMapping(&quot;/testinterceptor&quot;) public ModelAndView testInterceptor() { System.out.println(&quot;进入controller&quot;); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;aaa&quot;); System.out.println(&quot;即将返回modelandview&quot;); return mv; } } 4.启动项目访问http://127.0.0.1:8080/testinterceptor。 至此，过滤器、拦截器、监听器的基本使用完成，在实际项目中主要是考虑编写拦截业务等。例如在拦截器上判断是否进行黑白名单拦截，或者判断redis中token是否过期来判断是否可以访问请求。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"(五)SpringBoot热部署","slug":"(五)SpringBoot热部署","date":"2019-01-29T06:28:43.173Z","updated":"2019-01-29T06:34:10.848Z","comments":false,"path":"2019/01/29/(五)SpringBoot热部署/","link":"","permalink":"http://yoursite.com/2019/01/29/(五)SpringBoot热部署/","excerpt":"&#160; &#160; &#160; &#160;在前面的开发中不知道各位有没有发现，我们前端页面做修改只要保存， 不需要重启项目，重新访问就可以看见效果，但是在后端，例如controller中我们要改一个很小的值都要重新项目才能生效，这就显得特别的麻烦，所以，热部署可以让我们实现 类似前端页面保存就可以生效的效果，只需要加一个热部署的依赖即可。","text":"&#160; &#160; &#160; &#160;在前面的开发中不知道各位有没有发现，我们前端页面做修改只要保存， 不需要重启项目，重新访问就可以看见效果，但是在后端，例如controller中我们要改一个很小的值都要重新项目才能生效，这就显得特别的麻烦，所以，热部署可以让我们实现 类似前端页面保存就可以生效的效果，只需要加一个热部署的依赖即可。以之前的jsp demo为 例，在pom文件中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 重启项目，修改 controller 修改之后保存，直接访问 http://127.0.0.1:8080/testjsp，就可以发现，后台传过来的值已经变化了 页面模板 热部署，我就从书上截图下来","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"(四)SpringBoot页面模板与JSP","slug":"(四)SpringBoot页面模板与JSP","date":"2019-01-28T09:54:33.444Z","updated":"2019-01-29T06:24:24.647Z","comments":false,"path":"2019/01/28/(四)SpringBoot页面模板与JSP/","link":"","permalink":"http://yoursite.com/2019/01/28/(四)SpringBoot页面模板与JSP/","excerpt":"概述虽然在我们现在工作中，后端 人员一般只写接口，前后端分离，一般也使用不到页面模板，但是官方推荐使用thymeleaf，这边就蛮记录一下，对于jsp做过web开发的同志应该都会清楚，一些老项目基本是使用jsp，虽然官方已经不建议使用了，但是还是要了解一下。","text":"概述虽然在我们现在工作中，后端 人员一般只写接口，前后端分离，一般也使用不到页面模板，但是官方推荐使用thymeleaf，这边就蛮记录一下，对于jsp做过web开发的同志应该都会清楚，一些老项目基本是使用jsp，虽然官方已经不建议使用了，但是还是要了解一下。 Thymeleaf 了解thymeleaf之前我们要知道，SpringBoot默认的几个静态页面的目录： /static、/public、/resources 、/META-INF/resources 创建项目我们可以将项目中使用到的静态文件放在这几个项目中 首先我们创建一个SpringBoot项目 1.加入thymeleaf依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2.编写controller @Controller public class ThymeleafController { @RequestMapping(value = &quot;/testthymeleaf&quot;) public ModelAndView test(ModelAndView mv) { mv.setViewName(&quot;thymeleaf1&quot;); mv.addObject(&quot;name&quot;,&quot;欢迎使用Thymeleaf!&quot;); return mv; } } 3.在src/main/resources/templates目录下创建 thymeleaf.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;thymeleaf demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello thymeleaf&lt;/h1&gt; &lt;h2 th:text=&quot;&apos;名称：&apos;+${name}&quot;&gt;默认值&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 4.配置thymel信息，在application.properties下配置 #thymelea模板配置 spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.mode=HTML5 spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.content-type=text/html spring.thymeleaf.cache=false spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** 5.启动项目，浏览器访问http://127.0.0.1:8080/testthymeleaf 至此，Thymeleaf整合成功，当然thymeleaf还有很多内容，但是我个人也没用过，只是稍微了解 。 如果按照上面的做法 之后访问报404 的话 检查一下SpringBoot的版本，设置为1.3.3就可以解决了。 JSP对于一些老项目基本都是使用jsp，所以SpringBoot也有提供对jsp的支持 1.添加jsp的依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; 2.编写controller @Controller public class JspController { @GetMapping(&quot;/testjsp&quot;) public ModelAndView index() { ModelAndView mv = new ModelAndView(); mv.addObject(&quot;name&quot;, &quot;ccl&quot;); //模版名称，实际的目录为：src/main/webapp/jsp/index.html mv.setViewName(&quot;test&quot;); return mv; } } 3.在src/main/webapp/WEB-INF/jsp下创建test.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charsetUTF-8&quot;&gt; &lt;title&gt;jsp demo &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Jsp&lt;/h1&gt; &lt;h2 &gt;这是 ${name} 的jsp&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 4.配置jsp，在application.properties里配置： #jsp 支持 spring.mvc.view.suffix=.jsp spring.mvc.view.prefix=/WEB-INF/jsp/ 如果SpringBoot的版本太低的话配置为： #jsp 支持 spring.view.suffix=.jsp spring.view.prefix=/WEB-INF/jsp/ 5.启动项目，浏览器访问http://127.0.0.1:8080/testjsp 至此。SpringBoot整合jsp成功。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"(三)SpringBoot配置和多环境","slug":"(三)SpringBoot配置和多环境","date":"2019-01-28T06:46:59.842Z","updated":"2019-02-14T02:17:43.302Z","comments":false,"path":"2019/01/28/(三)SpringBoot配置和多环境/","link":"","permalink":"http://yoursite.com/2019/01/28/(三)SpringBoot配置和多环境/","excerpt":"配置文件介绍&#160; &#160; &#160; &#160;在第一个Springboot项目中我们知道，SpringBoot项目的默认 配置文件在main/resources下的application.properties下，我们接直接用之前的项目了解一下配置文件。","text":"配置文件介绍&#160; &#160; &#160; &#160;在第一个Springboot项目中我们知道，SpringBoot项目的默认 配置文件在main/resources下的application.properties下，我们接直接用之前的项目了解一下配置文件。&#160; &#160; &#160; &#160;application.properties配置文件中 配置整个springboot所需的配置，例如端口，项目名称，redis信息，到后续开发springcloud时的注册中心等等的配置信息，当然也可以自己自定义的配置项。 新增配置项&#160; &#160; &#160; &#160;我们打开application.properties，添加配置项： server.port=8083 name=this is default &#160; &#160; &#160; &#160;然后改写之前的HelloSpringBootController类 @RestController public class HelloSpringBootController { @Value(&quot;${name}&quot;) private String name; @RequestMapping(&quot;/sayHello&quot;) public String sayHello() { return &quot;Hello ,&quot;+this.name; } } 运行 接着启动项目可以看见： 启动了8083 端口 我们访问一下http://127.0.0.1:8083/sayHello，效果如下： 访问 成功，配置项正确获取了。 多环境配置但是在我们正常的开发中会有多个环境，测试环境，开发环境，生产环境，联调环境等等，每个环境下的配置不尽相同，那就需要我们配置多环境的配置文件： 首先在main/resources下 创建以下几个环境配置文件 修改各个配置文件的端口和name值 指定环境在application.properties下设置： spring.profiles.active=prod 确定当前使用的是哪个环境，这边环境的值与application-prod.properties中-后面的值对应，这是SpringBoot约定好的， 启动项目： 会发现启动了application-prod,properties配置下的8082端口，因为我们设置了当前的环境是prod，所以application-prod,properties生效了。 在浏览器中输入http://127.0.0.1:8082/sayHello，效果如下： 获取到 了正确的端口和值，可以依次测试各个环境。 基本的多环境配置如上述。 配置文件加载顺序 在命令行中传入的参数。 SPRING APPLICATION JSON 中 的属性. SPRING APPLICATION JSON 是 以JSON格式配置在系统环境变量中的内容。 3.javacomp/env中的JNDI属性。 4.Java的系统属性，可以通过system.getpropertieso获得的内容。 5.操作系统的环境变量。 6.通过random.*配置的随机属性。 7.位于当前应用jar包之外，针对不同(profile}环境的配置文件内容，例如application-{profile}·properties或是YAML定义的配置文件。 8.位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件。 9.位于当前应用jar包之外的application.properties和YAML配置内容。 10.位于当前应用jar包之内的application.properties和YAML配置内容。 11.在@Configuration注解修改的类中，通过@propertysource注解定义的属性。 12.应用默认属性，使用SpringApplication.setDefaultproperties定义的内容。优先级按上面的顺序由高到低，数字越小优先级越高。 项目打包发布但是在工作项目中我们将一个项目打包之后发布，springboot 项目使用java -jar xxx.jar 来启动项目。那么我们现在打包之后部署在开发环境中，配置文件中应该这样配置 spring.profiles.active=dev那么如果我们要将项目部署到测试环境中，是不是需要修改一下配置文件，然后重新打包部署呢？显然不是的，当然有更好的办法来解决。 首先我们将 项目打包，当然我们一般会有一些自动打包的脚本，但是这边我就 直接使用cmd打包 打开cmd进入当前项目的目录 运行mvn install （首先确认你已经安装了maven并且配置好环境变量，mvn是可以运行的） 运行成功之后进入target目录会看见，项目已经打包成jar了 cmd 继续进入target目录 （jar所在的目录） 运行： java -jar PropertiesSpringBoot-0.0.1-SNAPSHOT.jar --spring.profiles.active=test运行jar包，并使用–配置项=值，来设置配置项 可以看见启动了测试环境8083 访问正确！","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"(二)创建一个简单的SpringBoot应用","slug":"(二)创建一个简单的SpringBoot应用","date":"2019-01-28T06:16:10.974Z","updated":"2019-01-28T06:38:01.381Z","comments":false,"path":"2019/01/28/(二)创建一个简单的SpringBoot应用/","link":"","permalink":"http://yoursite.com/2019/01/28/(二)创建一个简单的SpringBoot应用/","excerpt":"&#160; &#160; &#160; &#160;接下来，我们就 一起来创建第一个SpringBoot 应用。创建SpringBoot项目过程中就会发现为什么SpringBoot会这么受欢迎了。关于IDE,写文章的时候使用的是Spring Tool Suite（STS），现在已经转为Idea，看个人喜好吧，自己怎么舒服怎么来，在工作中也没有强制一定要使用什么IDE。","text":"&#160; &#160; &#160; &#160;接下来，我们就 一起来创建第一个SpringBoot 应用。创建SpringBoot项目过程中就会发现为什么SpringBoot会这么受欢迎了。关于IDE,写文章的时候使用的是Spring Tool Suite（STS），现在已经转为Idea，看个人喜好吧，自己怎么舒服怎么来，在工作中也没有强制一定要使用什么IDE。 言归正传， 下面的教程都是使用STS。 创建项目创建一个Spring Starter project 点击NEXT 选择对用的版本和WEB项目然后选择finish首先创建一个项目 POM.XML打开项目的POM.XML 你会发现自动给你导入了一些依赖&#160; &#160; &#160; &#160;首先导入SpringBoot的依赖，因为我们刚才创建项目的时候选择了web， 所以还 自动导入了spring-boot-starter-web依赖。你也可以创建一个普通的 Maven然后将这些依赖导入一下是一个意思。 项目目录 项目入口类：类上使用@SpringBootApplication 标识 该类为项目的入口类 然后我们创建一个包 编写Controller &#160; &#160; &#160; &#160;注意我们创建的包必须是在程序入口类 所在包的子包，这样写的@RestController才会被扫描到 &#160; &#160; &#160; &#160;接着我们启动项目，在入口类上 右键==》Run as ==》 Spring Boot App 程序成功启动，默认端口为 8080 浏览器上输入：http://localhost:8080/sayHello 输出。完毕 一个简单的SpringBoot的项目就搭建成功了，非常方便，少去了spring spring mvc的配置，就可以快速的创建一个web项目。 一般来说使用SpringBoot的其他功能的步骤： 1.添加依赖 2..使用注解编写一些配置或代码 就可以了 。 题外话：&#160; &#160; &#160; &#160;启动的时候这块 标志是可以修改的，在java/main/resource 下创建一个banner.txt 文件，里面写入你要的内容，启动就可以看见这块标识已经 被修改了。 要生成类似的字体可以访问http://patorjk.com/software/taag去生成.其实没啥用。。。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"(一)SpringBoot概述","slug":"(一)SpringBoot概述","date":"2019-01-28T01:53:01.871Z","updated":"2019-01-28T06:27:01.013Z","comments":false,"path":"2019/01/28/(一)SpringBoot概述/","link":"","permalink":"http://yoursite.com/2019/01/28/(一)SpringBoot概述/","excerpt":"什么是SpringBoot&#160; &#160; &#160; &#160;我们知道Spring使用一个轻量级的企业开发一站式解决方案，提供了最主要的IOC、AOP等相关支持，但是在开发过程中会发现，项目中多而繁杂的配置文件总是让人头疼。而SpringBoot就是使用默认的配置来简化开发过程。","text":"什么是SpringBoot&#160; &#160; &#160; &#160;我们知道Spring使用一个轻量级的企业开发一站式解决方案，提供了最主要的IOC、AOP等相关支持，但是在开发过程中会发现，项目中多而繁杂的配置文件总是让人头疼。而SpringBoot就是使用默认的配置来简化开发过程。 &#160; &#160; &#160; &#160;随着动态语言的发展，传统的Java开发显得格外的笨重，效率低，配置文件多且杂，部署流程复杂，集成第三方难度大，所以 出现了SpringBoot。&#160; &#160; &#160; &#160;之前看过一句话,什么是SpringBoot？SpringBoot是一个专注于框架的框架。说白了SpringBoot就是简化开发， 提高效率的这么一个东西。 SpringBoot应用可以打包成jar 以jar包 形式运行 SpringBoot内职tomcat、jetty等，我们可 以像运行java application那样运行一个java web项目 SpringBoot提供 starter来简化Maven配置，我们只需要导入几个starter就可以省去好多 maven的配置 SpringBoot无代码生成和XML配置，使用“习惯优于配置“” 的想法来开发项目，在使用它的时候一般使用一些 注解，就可以完成，不需要写代码 SpringBoot对第三方的支持，支持各种第三方，只要导入依赖就能快速的使用，例如Mybatis等 &#160; &#160; &#160; &#160;说了这么多，还不如动手来试试 接下来我们来创建一个SpringBoot应用。 网上有很多大佬写了SpringBoot系列博客，该博文主要作为自己的技术总结，也希望对正在学习的朋友们有些许帮助。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]}]}